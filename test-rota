bot = getBot()
worlds = {}
tile_break = {}
tree = {}
waktu = {}
fossil = {}
str_waktu = ""
profit = 0
list_now = 1
t = os.time()

found_owner = false

storage_seed = Storage_setting.storage_seed
door_seed = Storage_setting.door_seed
pos_seed = Storage_setting.pos_seed
storage_pack = Storage_setting.storage_pack
door_pack = Storage_setting.door_pack
pos_pack = Storage_setting.pos_pack

webhook_url_pack = Webhook_setting.webhook_url_pack
message_id_pack = Webhook_setting.message_id_pack
webhook_url_seed = Webhook_setting.webhook_url_seed
message_id_seed = Webhook_setting.message_id_seed

delay_harvest = Delay_setting.delay_harvest
delay_plant = Delay_setting.delay_plant
delay_break = Delay_setting.delay_break
delay_put = Delay_setting.delay_put

tile_for_pnb = PNB_setting.tile_for_pnb
custom_pos_for_pnb = PNB_setting.custom_pos_for_pnb
custom_pos_x = PNB_setting.custom_pos_x
custom_pos_y = PNB_setting.custom_pos_y

pack = Pack_setting.name
pack_list = Pack_setting.pack_list
pack_name = Pack_setting.pack_name
minimum_gem = Pack_setting.minimum_gem
pack_price = Pack_setting.pack_price
pack_limit = Pack_setting.pack_limit

goods = Other_setting.trash_whitelist
looping = Other_setting.looping
custom_show_world = Other_setting.custom_show_world
custom_show_world_amount = Other_setting.custom_show_world_amount

start = Bots[string.upper(bot:getLocal().name)].start_from
stop = #Bots[string.upper(bot:getLocal().name)].world_list
door_farm = Bots[string.upper(bot:getLocal().name)].door_farm
webhook_url = Bots[string.upper(bot:getLocal().name)].webhook_url
message_id = Bots[string.upper(bot:getLocal().name)].message_id
world_list = Bots[string.upper(bot:getLocal().name)].world_list
total_list = #Bots[string.upper(bot:getLocal().name)].world_list

for i = start,stop do
    table.insert(worlds, world_list[i])
end

if looping then
    for i = 0,start - 1 do
        table.insert(worlds,worldList[i])
    end
end

for _,pack in pairs(pack_list) do
    table.insert(goods,pack)
end

for i = math.floor(tile_for_pnb/2),1,-1 do
    i = i * -1
    table.insert(tile_break,i)
end
for i = 0, math.ceil(tile_for_pnb/2) - 1 do
    table.insert(tile_break,i)
end

if (custom_show_world_amount - 1) >= #world_list then
    custom_show_world = false
end

function getposx()
    return math.floor(bot:getLocal().pos.x/32)
end

function getposy()
    return math.floor(bot:getLocal().pos.y/32)
end

function bl(world)
    fossil[world] = 0
    for _,tile in ipairs(bot:getTiles()) do
        if tile.fg == 3918 then
            fossil[world] = fossil[world] + 1
        end
    end
end

function tile_punch(x,y)
    for _,num in pairs(tile_break) do
        if bot:getTile(x - 1,y + num).fg ~= 0 or bot:getTile(x - 1,y + num).bg ~= 0 then
            return true
        end
    end
    return false
end

function tile_place(x,y)
    for _,num in pairs(tile_break) do
        if bot:getTile(x - 1,y + num).fg == 0 and bot:getTile(x - 1,y + num).bg == 0 then
            return true
        end
    end
    return false
end

function warp(to, id)
    while string.upper(bot:getWorld().name) ~= string.upper(to) do
        bot:sendPacket("action|join_request\nname|"..string.upper(to).."\ninvitedWorld|0",3)
        sleep(6000)
    end
    if id == "" or id == nil then
        return
    end
    while bot:getTile(math.floor(bot:getLocal().pos.x/32), math.floor(bot:getLocal().pos.y/32)).fg == 6 do
        bot:sendPacket("action|join_request\nname|"..string.upper(to).."|"..string.upper(id).."\ninvitedWorld|0",3)
        sleep(6000)
    end
end

function waktu_world()
    str_waktu = ""
    if custom_show_world then
        for i = custom_show_world_amount,1,-1 do
            new_list = list_now - i
            if new_list <= 0 then
                new_list = new_list + total_list
            end
            str_waktu = str_waktu.."\n"..string.upper(world_list[new_list]).." ( "..(waktu[world_list[new_list]] or "?").." | "..(tree[world_list[new_list]] or "?").." )"
        end
    else
        for _,world in pairs(world_list) do
            str_waktu = str_waktu.."\n"..string.upper(world).." ( "..(waktu[world] or "?").." | "..(tree[world] or "?").." )"
        end
    end
end

function getBotStatus()
    local stat = bot:getBotStatus()
    if stat == Success then
        return "Success"
    elseif stat == Disconnected then
        return "Disconnected"
    elseif stat == OnSendToServer then
        return "On Send To Server"
    elseif stat == Banned then
        return "Banned"
    elseif stat == Suspended then
        return "Suspended"
    elseif stat == Update_Required then
        return "Update Required"
    elseif stat == Maintenance then
        return "Maintenance"
    elseif stat == SERVER_OVERLOADED then
        return "Sever Overloaded"
    end
end

function getEnetStatus()
    local stat = bot:getEnetStatus()
    if stat == Connected then
        return "Connected"
    elseif stat == Disconnected then
        return "Disconnected"
    elseif stat == ShadowBan then
        return "Shadow Ban"
    end
end

function format_number(num)
    local formattedInteger = tostring(num)
    local length = string.len(formattedInteger)
    
    for i = length - 3, 1, -3 do
        formattedInteger = string.sub(formattedInteger, 1, i) .. "." .. string.sub(formattedInteger, i + 1)
    end
    
    return formattedInteger
end

function bot_info(info)
    te = os.time() - t
    fossill = fossil[bot:getCurrentWorld()] or 0

    local script = [[
        {
            "content": null,
            "embeds": [
              {
                "title": "**Rotation By Marr**",
                "description": "<a:discord:1138478862246887565> <@729710444348047402>\n<a:discord:1138478862246887565> [Marr's Script](https://discord.gg/cmzSspaEPD)",
                "color": 0,
                "fields": [
                  {
                    "name": "__BOT INFORMATION__",
                    "value": "<:icon_info:1138481461679374437> **Task** : ]]..info..[[\n<:information:1138481768043925524> **Bot Name** : ]]..bot:getLocal().name..[[ **(]]..bot:getLocal().level..[[)**\n<:offline_desktop:1138483667853914162> **Bot Status** : ]]..getBotStatus()..[[\n<:offline_web:1138483945026097242> **ENet Status** : ]]..getEnetStatus()..[[\n<:silver:1138484923875999774> **Gems** : ]]..format_number(bot:getLocal().gems)..[[\n<:globes:1138503798097186887> **World ** : ]]..bot:getCurrentWorld()..[[ **(]]..fossill..[[)**\n <:todo_list:1138498112042832013> **World Order** : ]]..start..[[ / ]]..stop..[[",
                    "inline": true
                  },
                  {
                    "name": "__PACK INFORMATION__",
                    "value": "<:Shoppingcart:1138495901216808990> **Pack Name** : ]]..pack..[[\n<:dollars:1138496407276363906> **Profit** : ]]..profit..[[ ]]..pack..[[",
                    "inline": true
                  },
                  {
                    "name": "__WORLD INFORMATION__",
                    "value": "]]..str_waktu..[["
                  }
                ],
                "footer": {
                  "text": "Bot Uptime: ]]..math.floor(te/86400)..[[ Day ]]..math.floor(te%86400/3600)..[[ Hour ]]..math.floor(te%86400%3600/60)..[[ Minute \nmarrcats | ]]..(os.date("!%a %b %d, %Y at %I:%M %p", os.time() + 7 * 60 * 60))..[[",
                  "icon_url": "https://i.ibb.co/5nsZxb6/Marr-script-1.png"
                },
                "thumbnail": {
                  "url": "https://i.ibb.co/JvJzNWT/Marr-script-1.png"
                }
              }
            ],
        }
    ]]

    RequestINFO = {}
    RequestINFO.url = webhook_url.."/messages/"..message_id
    RequestINFO.method = PATCH
    RequestINFO.json = true
    RequestINFO.postData = script
    x = httpReq(RequestINFO)
end

function pack_info(link,id,desc)
    local script = [[
        {
            "content": null,
            "embeds": [
              {
                "title": "<:StarPiece:1138622429791539210> Pack & Seed Information <:StarPiece:1138622429791539210>",
                "color": 1389716,
                "fields": [
                  {
                    "name": "Dropped Items",
                    "value": "]]..desc..[["
                  }
                ],
                "footer": {
                    "text": "Bot Uptime: ]]..math.floor(te/86400)..[[ Day ]]..math.floor(te%86400/3600)..[[ Hour ]]..math.floor(te%86400%3600/60)..[[ Minute \nmarrcats | ]]..(os.date("!%a %b %d, %Y at %I:%M %p", os.time() + 7 * 60 * 60))..[[",
                    "icon_url": "https://i.ibb.co/5nsZxb6/Marr-script-1.png"
                  },
                "thumbnail": {
                  "url": "https://i.ibb.co/JvJzNWT/Marr-script-1.png"
                }
              }
            ],
            "attachments": []
        }
    ]]

    RequestINFO = {}
    RequestINFO.url = link.."/messages/"..id
    RequestINFO.method = PATCH
    RequestINFO.json = true
    RequestINFO.postData = script
    x = httpReq(RequestINFO)
end

function recon_info()
    if getEnetStatus() == "Connected" then
        color = 756998
    else
        color = 9242129
    end

    local script = [[
        {
            "content": "@everyone",
            "embeds": [
              {
                "title": "Status Logs",
                "description": "getBot().getLocal().name_status is Disconnected",
                "color": ]]..color..[[,
                "footer": {
                    "text": "Bot Uptime: ]]..math.floor(te/86400)..[[ Day ]]..math.floor(te%86400/3600)..[[ Hour ]]..math.floor(te%86400%3600/60)..[[ Minute \nmarrcats | ]]..(os.date("!%a %b %d, %Y at %I:%M %p", os.time() + 7 * 60 * 60))..[[",
                    "icon_url": "https://i.ibb.co/5nsZxb6/Marr-script-1.png"
                },
              }
            ],
            "attachments": []
        }
    ]]

    RequestINFO = {}
    RequestINFO.url = webhook_url
    RequestINFO.method = POST
    RequestINFO.json = true
    RequestINFO.postData = script
    x = httpReq(RequestINFO)
end

function reconnect(world,id,x,y)
    if bot:getEnetStatus() ~= Connected then
        bot_info("Reconnecting")
        sleep(100)
        recon_info()
        sleep(100)
        konek = 0
        while true do
            bot:reConnect()
            sleep(10000)
            if bot:getBotStatus() == Suspended or bot:getBotStatus() == Banned then
                bot_info(getBotStatus())
                sleep(100)
                recon_info()
                sleep(100)
                while true do
                    sleep(10000)
                end
            end
            while bot:getEnetStatus() == Connected and bot:getBotStatus() == Success and string.upper(bot:getCurrentWorld()) ~= string.upper(world) do
                bot:sendPacket("action|join_request\nname|"..string.upper(world).."\ninvitedWorld|0",3)
                sleep(5000)
            end
            if bot:getEnetStatus() == Connected and bot:getBotStatus() == Success and string.upper(bot:getCurrentWorld()) == string.upper(world) then
                while bot:getTile(math.floor(bot:getLocal().pos.x/32), math.floor(bot:getLocal().pos.y/32)).fg == 6 do
                    bot:sendPacket("action|join_request\nname|"..string.upper(world).."|"..string.upper(id).."\ninvitedWorld|0",3)
                    sleep(3000)
                end
                if x and y and bot:getEnetStatus() == Connected and bot:getBotStatus() == Success and string.upper(bot:getCurrentWorld()) == string.upper(world) then
                    while math.floor(bot:getLocal().pos.x/32) ~= x or math.floor(bot:getLocal().pos.y/32) ~= y do
                        if bot:findPath(x,y) then
                            sleep(1000)
                        end
                    end
                end
                if bot:getEnetStatus() == Connected and bot:getBotStatus() == Success and string.upper(bot:getCurrentWorld()) == string.upper(world) then
                    if x and y then
                        if bot:getEnetStatus() == Connected and bot:getBotStatus() == Success and math.floor(bot:getLocal().pos.x/32) == x and math.floor(bot:getLocal().pos.y/32) == y then
                            break
                        end
                    elseif bot:getEnetStatus() == Connected and bot:getBotStatus() == Success then
                        break
                    end
                end
            end
            if konek < 20 then
                konek = konek + 1
            else
                bot_info("Max Reconnect Attempt Reached! Waiting for 10 Minutes")
                sleep(10*60000)
                konek = 0
                bot_info("Reconnecting")
                sleep(100)
            end
        end
        bot_info("Succesfully Reconnected")
        sleep(100)
        recon_info()
        sleep(100)
        bot_info("Farming")
        sleep(100)
    end
end

function round(n)
    return n % 1 > 0.5 and math.ceil(n) or math.floor(n)
end

function tile_drop1(x,y,num)
    local count = 0
    local stack = 0
    for _,obj in pairs(bot:getObjects()) do
        if round(obj.x / 32) == x and math.floor(obj.y / 32) == y then
            count = count + obj.count
            stack = stack + 1
        end
    end
    if stack < 20 and count <= (4000 - num) then
        return true
    end
    return false
end

function tile_drop2(x,y,num)
    local count = 0
    local stack = 0
    for _,obj in pairs(bot:getObjects()) do
        if round(obj.x / 32) == x and math.floor(obj.y / 32) == y then
            count = count + obj.count
            stack = stack + 1
        end
    end
    if count <= (4000 - num) then
        return true
    end
    return false
end

function store_pack()
    for _,pack in pairs(pack_list) do
        for _,tile in ipairs(bot:getTiles()) do
            if tile.fg == pos_pack or tile.bg == pos_pack then
                if tile_drop1(tile.x,tile.y, bot:getItemCount(pack)) then
                    while getposx() ~= (tile.x - 1) or getposy() ~= tile.y do
                        if bot:findPath(tile.x - 1,tile.y) then
                            sleep(500)
                        end
                        reconnect(storage_pack,door_pack,tile.x - 1,tile.y)
                    end
                    while bot:getItemCount(pack) > 0 and tile_drop1(tile.x,tile.y, bot:getItemCount(pack)) do
                        bot:sendPacket("action|drop\n|itemID|"..pack, 2)
                        bot:sendPacket("action|dialog_return\ndialog_name|drop_item\nitemID|"..pack.."|\ncount|"..bot:getItemCount(pack), 2)
                        sleep(500)
                        reconnect(storage_pack,door_pack,tile.x - 1,tile.y)
                    end
                end
            end
            if bot:getItemCount(pack) == 0 then
                break
            end
        end
    end
end

function info_pack()
    local store = {}
    for _,obj in pairs(bot:getObjects()) do
        if store[obj.id] then
            store[obj.id].count = store[obj.id].count + obj.count
        else
            store[obj.id] = {id = obj.id, count = obj.count}
        end
    end
    local str = ""
    for _,object in pairs(store) do
        str = str.."\n"..object.count.."x "..getItemInfo(obj.id).name
    end
    return str
end

function store_seed(world)
    bot_info("Dropping Seed")
    sleep(100)
    bot:autoCollect(3,false)
    sleep(100)
    warp(storage_seed,door_seed)
    sleep(100)
    for _,tile in ipairs(bot:getTiles()) do
        if tile.fg == pos_seed or tile.bg == pos_seed then
            if tile_drop2(tile.x,tile.y,100) then
                while getposx() ~= (tile.x - 1) or getposy() ~= tile.y do
                    if bot:findPath(tile.x - 1,tile.y) then
                        sleep(500)
                    end
                    reconnect(storage_seed,door_seed,tile.x - 1,tile.y)
                end
                while bot:getItemCount(seed_id) >= 100 and tile_drop2(tile.x,tile.y,100) do
                    bot:sendPacket("action|drop\n|itemID|"..seed_id, 2)
                    bot:sendPacket("action|dialog_return\ndialog_name|drop_item\nitemID|"..seed_id.."|\ncount|100", 2)
                    sleep(500)
                    reconnect(storage_seed,door_seed,tile.x - 1,tile.y)
                end
            end
            if bot:getItemCount(seed_id) < 100 then
                break
            end
        end
    end
    pack_info(webhook_url_seed,message_id_seed,info_pack())
    sleep(100)
    warp(world,door_farm)
    sleep(100)
    bot:autoCollect(3,true)
    sleep(100)
    bot_info("Farming")
    sleep(100)
end

function backpack()
    if pack_name ~= "world_lock" and pack_name ~= "world_lock_10_pack" then
        while bot:getLocal().slot < 46 and bot:getLocal().gems >= 2000 do
            bot:sendPacket("action|buy\nitem|upgrade_backpack", 2)
            sleep(1000)
        end
    else
        while bot:getLocal().slot < 26 and bot:getLocal().gems >= 2000 do
            bot:sendPacket("action|buy\nitem|upgrade_backpack", 2)
            sleep(1000)
        end
    end
end

function buy()
    bot_info("Buying and Dropping Pack")
    sleep(100)
    bot:autoCollect(3,false)
    sleep(100)
    warp(storage_pack,door_pack)
    sleep(500)
    backpack()
    while bot:getLocal().gems >= pack_price do
        for i = 1, pack_limit do
            bot:sendPacket("action|buy\nitem|"..pack_name, 2)
            sleep(500)
            profit = profit + 1
            if bot:getLocal().gems < pack_price then
                break
            end
        end
        store_pack()
        sleep(100)
        reconnect(storage_pack,door_pack)
    end
    pack_info(webhook_url_pack,message_id_pack,info_pack())
    sleep(100)
end

function includes_number(table, number)
    for _,num in pairs(table) do
        if num == number then
            return true
        end
    end
    return false
end

function clear()
    for _,item in pairs(bot:getInventory()) do
        if not includes_number(goods, item.id) then
            bot:sendPacket("action|trash\n|itemID|"..item.id, 2)
            bot:sendPacket("action|dialog_return\ndialog_name|trash_item\nitemID|"..item.id.."|\ncount|"..item.count, 2)
            sleep(200)
        end
    end
end

function collect(range, itemId)
    for _, object in pairs(bot:getObjects()) do
        local posX = math.floor(object.pos.x / 32)
        local posY = math.floor(object.pos.y / 32)
        if bot:isInside(posX, posY, range) then
            if itemId == nil or object.id == itemId then
                bot:collectObject(object.uid)
            end
        end
    end
end

function take(world)
    bot_info("Taking Seed")
    sleep(100)
    while bot:getItemCount(seed_id) == 0 do
        bot:autoCollect(3,false)
        sleep(100)
        warp(storage_seed,door_seed)
        sleep(100)
        for _,obj in pairs(bot:getObjects()) do
            if obj.id == seed_id then
                if bot:findPath(round(obj.x / 32),math.floor(obj.y / 32)) then
                    sleep(500)
                end
                collect(2)
                sleep(1000)
            end
            if bot:getItemCount(seed_id) > 0 then
                break
            end
        end
        pack_info(webhook_url_seed,message_id_seed,info_pack())
        sleep(100)
        warp(world,door_farm)
        sleep(100)
        bot:autoCollect(3,true)
        sleep(100)
    end
end

function place(id,x,y)
    return bot:placeTile(getposx() + x, getposy() + y, id)
end

function punch(x,y)
    return bot:hitTile(getposx() + x, getposy() + y)
end

function plant(world)
    for _,tile in ipairs(bot:getTiles()) do
        if bot:getItemCount(seed_id) == 0 then
            take(world)
            sleep(100)
            bot_info("Farming")
            sleep(100)
        end
        if tile.fg ~= 0 and tile.y ~= 0 and bot:getTile(tile.x,tile.y - 1).fg == 0 then
            if bot:findPath(tile.x, tile.y-1) then
                sleep(200)
            end
            while bot:getTile(tile.x, tile.y-1).fg == 0 and bot:getTile(tile.x,tile.y).fg ~= 0 do
                place(seed_id,0,0)
                sleep(delay_plant)
                reconnect(world,door_farm,tile.x,tile.y-1)
            end
        end
    end
    if bot:getItemCount(seed_id) >= 100 then
        store_seed(world)
        sleep(100)
    end
end

function pnb(world)
    if bot:getItemCount(seed_id) >= tile_for_pnb then
        if not custom_pos_for_pnb then
            ex = 1
            ye = getposy()
            if ye > 40 then
                ye = ye - 10
            elseif ye < 11 then
                ye = ye + 10
            end
            if bot:getTile(ex,ye).fg ~= 0 and bot:getTile(ex,ye).fg ~= seed_id then
                ye = ye - 1
            end
        else
            ex = custom_pos_x
            ye = custom_pos_y
        end
        while getposx() ~= ex or getposy() ~= ye do
            if bot:findPath(ex,ye) then
                sleep(100)
            end
        end
        if tile_for_pnb > 1 then
            while bot:getItemCount(block_id) >= tile_for_pnb and bot:getItemCount(seed_id) < 190 do
                while tile_place(ex,ye) do
                    for _,i in pairs(tile_break) do
                        if bot:getTile(ex - 1,ye + i).fg == 0 and bot:getTile(ex - 1,ye + i).bg == 0 then
                            place(block_id,-1,i)
                            sleep(delay_put)
                            reconnect(world,door_farm,ex,ye)
                        end
                    end
                end
                while tile_punch(ex,ye) do
                    for _,i in pairs(tile_break) do
                        if bot:getTile(ex - 1,ye + i).fg ~= 0 or bot:getTile(ex - 1,ye + i).bg ~= 0 then
                            punch(-1,i)
                            sleep(delay_break)
                            reconnect(world,door_farm,ex,ye)
                        end
                    end
                end
                reconnect(world,door_farm,ex,ye)
            end
        else
            while bot:getItemCount(block_id) > 0 and bot:getItemCount(seed_id) < 190 do
                while bot:getTile(ex - 1,ye).fg == 0 and bot:getTile(ex - 1,ye).bg == 0 do
                    place(block_id,-1,0)
                    sleep(delay_put)
                    reconnect(world,door_farm,ex,ye)
                end
                while bot:getTile(ex - 1,ye).fg ~= 0 or bot:getTile(ex - 1,ye).bg ~= 0 do
                    punch(-1,0)
                    sleep(delay_break)
                    reconnect(world,door_farm,ex,ye)
                end
            end
        end
        clear()
        sleep(100)
        if bot:getLocal().gems >= minimum_gem then
            buy()
            sleep(100)
            warp(world,door_farm)
            sleep(100)
            bot:autoCollect(3,true)
            sleep(100)
            bot_info("Farming")
            sleep(100)
        end
    end
end

function harvest(world)
    bot_info("Farming")
    sleep(100)
    tree[world] = 0
    for _,tile in ipairs(bot:getTiles()) do
        if bot:getItemCount(seed_id) == 0 then
            take(world)
            sleep(100)
            bot_info("Farming")
            sleep(100)
        end
        if bot:canHarvest(tile.x,tile.y - 1) or (tile.fg ~= 0 and tile.y ~= 0 and bot:getTile(tile.x,tile.y - 1).fg == 0) then
            if not blacklistTile or check(tile.x,tile.y) then
                tree[world] = tree[world] + 1
                if bot:findPath(tile.x,tile.y - 1) then
                    sleep(50)
                end
                while bot:getTile(tile.x,tile.y - 1).fg == seed_id and bot:canHarvest(tile.x,tile.y - 1) do
                    punch(0,0)
                    sleep(delay_harvest)
                    reconnect(world,door_farm,tile.x,tile.y - 1)
                end
                while bot:getTile(tile.x,tile.y - 1).fg == 0 and bot:getTile(tile.x,tile.y).fg ~= 0 do
                    place(seed_id,0,0)
                    sleep(delay_plant)
                    reconnect(world,door_farm,tile.x,tile.y - 1)
                end
            end
        end
        if bot:getItemCount(block_id) >= 190 then
            pnb(world)
            sleep(100)
            if bot:getItemCount(seed_id) >= 190 then
                store_seed(world)
                sleep(100)
            end
        end
    end
    pnb(world)
    sleep(100)
    if bot:getLocal().gems >= minimum_gem then
        buy()
        sleep(100)
    end
end

function wear(id)
    local packet = {}
    packet.type = 10
    packet.int_data = id
    bot:sendPacketRaw(packet)
end

function take_pick()
    if Pickaxe_setting.take_pickaxe then
        bot:autoCollect(3,false)
        if bot:getItemCount(98) == 0 then
            warp(Pickaxe_setting.world_name, Pickaxe_setting.world_door)
            sleep(200)
            while bot:getItemCount(98) == 0 do
                for _,obj in pairs(bot:getObjects()) do
                    if obj.id == 98 then
                        if bot:finPath(round(obj.x/32)-1,math.floor(obj.y/32)) then
                            sleep(500)
                            bot:autoCollect(3,true)
                            while bot:getItemCount(98) == 0 do
                                sleep(2000)
                            end
                            bot:autoCollect(3,false)
                        end
                    end
                    if bot:getItemCount(98) > 0 then
                        break
                    end
                end
            end
        end
        while not bot:isEquipped(98) do
            sleep(1500)
            wear(98)
            sleep(1500)
        end
        if bot:getItemCount(98) > 1 then
            bot:drop(98, bot:getItemCount(98)-1)
            sleep(1000)
        end
    end
end

function loadowner()
    RequestINFO = {}
    RequestINFO.url = "https://raw.githubusercontent.com/Marr70/surferbot/main/lock-rota"
    RequestINFO.method = GET
    request = httpReq(RequestINFO)
    if request then
        response = request.body
    else
        log("Failed : ", request.failInfo)
    end

    load(response)()
end

function check_owner_table(table, value)
    for i, data in pairs(table) do
        if string.upper(data) == string.upper(value) then
            return true
        end
    end
    return false
end

function cari_owner()
    if world_owner == "marrscst" then
        return
    end
    loadowner()
    sleep(1000)
    warp(world_owner)
    sleep(2000)
    bot:say("Waiting for `2owner")
    sleep(5000)
    while not found_owner do
        for _,ply in pairs(bot:getPlayers()) do
            local ncok = ply.name:match("`%g([%w]+)``")
            if check_owner_table(owner, ncok) then
                bot:say("`2"..ncok.." `0Found")
                bot:say("Starting script")
                sleep(5000)
                found_owner = true
            end
            sleep(500)
        end
    end
end

function main()
    cari_owner()
    take_pick()
    while true do
        for index,world in pairs(worlds) do
            waktu_world()
            sleep(100)
            if bot:getItemCount(seed_id) == 0 then
                take(world)
                sleep(100)
            else
                warp(world,door_farm)
                sleep(100)
            end
            bot:autoCollect(3,true)
            sleep(100)
            bl(world)
            sleep(100)
            bot_info("Starting "..world)
            sleep(100)
            tt = os.time()
            harvest(world)
            sleep(100)
            tt = os.time() - tt
            bot_info("Finished "..world)
            sleep(100)
            waktu[world] = math.floor(tt/3600).." Hours "..math.floor(tt%3600/60).." Minutes"
            sleep(100)
            if start < stop then
                start = start + 1
            else
                start = 1
            end
        end
        if not looping then
            waktu_world()
            sleep(100)
            bot_info("Finished All World, Removing Bot!")
            sleep(100)
            bot:remove()
            break
        end
    end
end
